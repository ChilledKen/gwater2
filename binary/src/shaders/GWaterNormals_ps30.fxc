float2 SCR_S : register(c0);
float RADIUS : register(c1);
sampler NORMALS : register(s0);

struct PS_INPUT {
	float2 P 			: VPOS;
	float2 world_coord	: TEXCOORD0;
	float3 world_dir 	: TEXCOORD1;
	float3x3 world_normal : TEXCOORD2;
	float3 world_color	: COLOR0;
};

struct PS_OUTPUT {
	float4 rt0		    : COLOR0;
	float4 rt1          : COLOR1;
	float4 rt2			: COLOR2;
	//float4 rt3			: COLOR3;
	//float depth			: DEPTH0;
};

bool is_zero(float4 i) {
	return i.x == 0 && i.y == 0 && i.z == 0 && i.w == 0;
};

PS_OUTPUT main(PS_INPUT i) : COLOR {
	float2 world_offset = (i.world_coord - 0.5) * 2.0;

	// kill pixels outside of sphere
	float radius2 = dot(world_offset, world_offset);
	if (radius2 > 1) discard;

	// Calculate normal from sprite
	float3 final_normal = mul(float3(world_offset.x, sqrt(1 - radius2), world_offset.y), i.world_normal);

	//float3 final_normal = right * world_offset.x + forward * sqrt(1 - radius2) + up * world_offset.y;

	// Depth information for normals smoothing
	float2 uvdx = ddx(i.world_coord);
	float2 uvdy = ddy(i.world_coord);
	float uvdmax = 1.0 / sqrt(max(dot(uvdx, uvdx), dot(uvdy, uvdy)));
	float dist = length(i.world_dir);

	// Graphics Code Here
	float4 test = tex2D(NORMALS, i.P / SCR_S);
	if (is_zero(test)) test = float4(final_normal, 1);

	PS_OUTPUT o = (PS_OUTPUT)0;
	o.rt0 = float4(i.P.x / SCR_S.x, i.P.y / SCR_S.y, 0, 1);
	o.rt1 = float4(final_normal, 1);
	o.rt2 = float4(uvdmax, dist, 0, 1);

	return o;
};
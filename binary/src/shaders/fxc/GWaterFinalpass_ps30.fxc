//  DYNAMIC: "OPAQUE" "0..1"

#include "common_ps_fxc.h"

float2 SCR_S		: register(c0);
float RADIUS		: register(c1);
float IOR 			: register(c2);
float REFLECTANCE 	: register(c3);
float4 COLOR2		: register(c4);

sampler NORMALS 	: register(s0);
sampler FRAMEBUFFER : register(s1);
sampler CUBEMAP		: register(s2);
sampler DEPTH		: register(s3);

struct PS_INPUT {
	float2 P 			: VPOS;
	float2 coord		: TEXCOORD0;
	float3 view_dir		: TEXCOORD1;
	float3 pos			: TEXCOORD2;
	float4x4 proj		: TEXCOORD3;
};

#define OFFSET float2(0.5, 0.5)
#define SUN_DIR float3(-0.377821, 0.520026, 0.766044)	// TODO: get from map OR get lighting data

bool is_zero(float3 i) {
	return i.x == 0 && i.y == 0 && i.z == 0;
}

// Assumes that incoming IOR is 1
/*
float fresnel_approx(const float3 incident, const float3 normal) {
	float fresnel = saturate(dot(normal, incident));
	return pow(1.0 - fresnel, 5);
}*/

float fresnel_approx(float n1, float n2, float3 normal, float3 incident, float ref) {
        float r0 = (n1 - n2) / (n1 + n2);
        r0 *= r0;
        float cosX = -dot(normal, incident);
        /*if (n1 > n2){
            float n = n1/n2;
            float sinT2 = n*n*(1.0-cosX*cosX);
            if (sinT2 > 1.0)
                return 1.0;
            cosX = sqrt(1.0-sinT2);
        }*/
        float x = 1.0-cosX;
        float ret = r0+(1.0-r0)*x*x*x*x*x;
        ret = (ref + (1.0-ref) * ret);
        return ret % 1.0;
}


float4 main(const PS_INPUT i) : COLOR {
	// kill pixels outside of sphere
	float2 offset = (i.coord - 0.5) * 2.0;
	float radius2 = dot(offset, offset);
	if (radius2 > 1) discard;

	float3 smoothed_normal = tex2D(NORMALS, i.P * SCR_S).xyz;
	
	// Weight the normals forward, as the only visible part is facing the player
	smoothed_normal = normalize(smoothed_normal + i.view_dir * dot(-i.view_dir, smoothed_normal) * REFLECTANCE);

	// Primary lighting calculations
	float3 reflected = reflect(i.view_dir, smoothed_normal);
	float phong = min(pow(max(0, dot(reflected, SUN_DIR)), 100), 1);
	float fresnel = fresnel_approx(1.0, 1.333, i.view_dir, smoothed_normal, 0.1); //is_zero(smoothed_normal) ? 0 : fresnel_approx(1.0, 1.333, i.view_dir, smoothed_normal, 0.1);
	float3 specular = (ENV_MAP_SCALE * texCUBE(CUBEMAP, reflected)).xyz * fresnel;
	//float3 specular = pow(texCUBE(CUBEMAP, reflected).xyz, 1.0 / 2.2) * 3.5 * fresnel;

	// Secondary lighting calculations
	
#if OPAQUE // Opaque
	float3 absorption = COLOR2.xyz;// * (1.0 - fresnel);
	float diffuse = dot(smoothed_normal, SUN_DIR) * 0.45 + 0.55;

	float3 final_color = absorption * diffuse  + float3(phong, phong, phong) + specular;
	
#else // Translucent
	// Calculate refraction vector in 3d space and project it to screen
	float3 uv_offset = smoothed_normal * -RADIUS * IOR;
	float4 uv = mul(float4(i.pos + uv_offset, 1), i.proj); uv.xy /= uv.w;
	
	float2 refract_pos = float2(uv.x / 2.0 + 0.5, 0.5 - uv.y / 2.0);
	float3 refracted = tex2D(FRAMEBUFFER, refract_pos).xyz * (1.0 - fresnel);

	float absorption_distance = (tex2D(DEPTH, refract_pos).x * 100 - dot(smoothed_normal, i.view_dir) * 10) * COLOR2.w;
	float3 absorption = exp((COLOR2.xyz - float3(1, 1, 1)) * absorption_distance);	// Beers law

	float3 final_color = absorption * refracted + float3(phong, phong, phong) + specular;
#endif

	// Calculate final color & return
	return FinalOutput(float4(final_color, 1), 0, 0, TONEMAP_SCALE_NONE);	// For HDR
};